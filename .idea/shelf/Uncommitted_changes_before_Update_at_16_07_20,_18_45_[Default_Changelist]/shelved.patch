Index: .idea/shelf/Uncommitted_changes_before_Update_at_09_07_20__11_00__Default_Changelist_.xml
===================================================================
--- .idea/shelf/Uncommitted_changes_before_Update_at_09_07_20__11_00__Default_Changelist_.xml	(revision 5f7933976d28d2cdafe231ff3fa01d2c47117bb8)
+++ .idea/shelf/Uncommitted_changes_before_Update_at_09_07_20__11_00__Default_Changelist_.xml	(revision 5f7933976d28d2cdafe231ff3fa01d2c47117bb8)
@@ -1,9 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_09_07_20,_11_00_[Default_Changelist]" date="1594285234199" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_09_07_20,_11_00_[Default_Changelist]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 09/07/20, 11:00 [Default Changelist]" />
-  <binary>
-    <option name="BEFORE_PATH" value="Assets/Images/BG/bg.jpg" />
-    <option name="AFTER_PATH" value="Assets/Images/BG/bg.jpg" />
-    <option name="SHELVED_PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_09_07_20,_11_00_[Default_Changelist]/bg.jpg" />
-  </binary>
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_09_07_20,_11_00_[Default_Changelist]/shelved.patch
===================================================================
--- .idea/shelf/Uncommitted_changes_before_Update_at_09_07_20,_11_00_[Default_Changelist]/shelved.patch	(revision 5f7933976d28d2cdafe231ff3fa01d2c47117bb8)
+++ .idea/shelf/Uncommitted_changes_before_Update_at_09_07_20,_11_00_[Default_Changelist]/shelved.patch	(revision 5f7933976d28d2cdafe231ff3fa01d2c47117bb8)
@@ -1,126 +0,0 @@
-Index: States/PlayState.cpp
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>//\n// Created by Lorenzo Massa on 31/05/2020.\n//\n\n#include <cmath>\n#include \"PlayState.h\"\n\n\n\n\nPlayState::PlayState(const std::shared_ptr<sf::RenderWindow>& targetWindow, int level) : GameState(targetWindow) {\n    this->level = level;\n    Game::getGame()->getMapHandler()->loadLevel(level);\n\n    action = 0;\n    directionClock = std::make_shared<sf::Clock>();\n    combactClock = std::make_shared<sf::Clock>();\n\n    sf::View tempView = targetWindow->getView();\n    tempView.setCenter(tempView.getSize().x/2 - Game::getGame()->getHero()->sf::Sprite::getPosition().x,tempView.getSize().y/2);\n    targetWindow->setView(tempView);\n\n    AssetManager::initBackground(targetWindow,- Game::getGame()->getHero()->sf::Sprite::getPosition().x);\n}\n\nvoid PlayState::handleInput() {\n    sf::Vector2f speed;\n\n    sf::Event event{};\n    while (targetWindow->pollEvent(event)) {\n        if (event.type == sf::Event::Closed)\n            targetWindow->close();\n        else if (event.type == sf::Event::Resized) {\n            sf::Vector2u size = targetWindow->getSize();\n            targetWindow->setView(sf::View(sf::FloatRect(0, 0, size.x, size.y)));\n            AssetManager::setBackground(targetWindow, 0);\n        } else if (event.type == sf::Event::KeyPressed) {\n            if (event.key.code == sf::Keyboard::Escape) {\n                Game::getGame()->save();\n                Game::getGame()->getStateHandler()->addState(std::make_shared<PauseState>(targetWindow));\n            }\n            if (event.key.code == sf::Keyboard::W || event.key.code == sf::Keyboard::Up|| event.key.code == sf::Keyboard::Space) {\n                if(Game::getGame()->getHero()->getSpeed().y==0.0f)\n                    Game::getGame()->getHero()->jump();\n            }\n            if (event.key.code == sf::Keyboard::A || event.key.code == sf::Keyboard::Left) {\n                Game::getGame()->getHero()->setDirection(-1.0f);\n                //speed.x =10.0f*64.0f;\n                speed= Game::getGame()->getHero()->getSpeed();\n                Game::getGame()->getHero()->setSpeed(sf::Vector2f( speed.x,speed.y));\n            }\n            if (event.key.code == sf::Keyboard::D || event.key.code == sf::Keyboard::Right) {\n                Game::getGame()->getHero()->setDirection(1.0f);\n                //speed.x =10.0f*64.0f; //Game::getGame()->getHero()->getSpeed();\n                speed= Game::getGame()->getHero()->getSpeed();\n                Game::getGame()->getHero()->setSpeed(sf::Vector2f( speed.x,speed.y));\n            }\n        } else if (event.type == sf::Event::KeyReleased) {\n            if (event.key.code == sf::Keyboard::A || event.key.code == sf::Keyboard::Left) {\n                Game::getGame()->getHero()->setDirection(0.0f);\n\n            }\n            if (event.key.code == sf::Keyboard::D || event.key.code == sf::Keyboard::Right) {\n                Game::getGame()->getHero()->setDirection(0.0f);\n\n            }\n        } else if (event.type == sf::Event::MouseButtonPressed){\n            switch(event.key.code) {\n                case sf::Mouse::Left:\n                    sf::Vector2i mousePosition = sf::Vector2i (sf::Mouse::getPosition(*targetWindow));\n                    sf::Vector2f mouseWorldPosition = targetWindow->mapPixelToCoords(mousePosition);\n\n                    mouseWorldPosition.x -= Game::getGame()->getHero()->getTexture()->getSize().x * Game::getGame()->getHero()->getScale().x/2.0f;\n                    mouseWorldPosition.y -= Game::getGame()->getHero()->getTexture()->getSize().y * Game::getGame()->getHero()->getScale().y/2.0f;\n\n                    //std::cout<<\"Mouse Position X: \"<<mousePosition.x<<\" Y: \"<<mousePosition.y<<std::endl;\n\n                    std::shared_ptr<Bullet> b = Game::getGame()->getHero()->shot(mouseWorldPosition);\n                    b->setFriendly(true);\n\n                    if (Game::getGame()->getHero()->getAmmo() >= 0)\n                            Game::getGame()->getMapHandler()->getMap()->addBullet(b);\n\n                    break;\n\n            }\n        }\n    }\n\n    animationHero(Game::getGame()->getHero()->getDirection(), speed);\n\n}\n\nvoid PlayState::generateFrame() {\n\n\n    sf::Vector2f move = isLegalMovement(Game::getGame()->getHero(),Game::getGame()->getHero()->move(sf::Vector2f(Game::getGame()->getHero()->getDirection(),\n                                                                 1.0f),Game::getGame()->getClock()->getElapsedTime().asSeconds()));\n    if(move.x != 0 || move.y != 0){\n        Game::getGame()->getHero()->sf::Sprite::move(move);\n        if(Game::getGame()->getHero()->sf::Sprite::getPosition().y > 16*64)\n            Game::getGame()->killHero();\n    }\n\n    sf::View tempView = targetWindow->getView();\n\n       if ((Game::getGame()->getHero()->getPosition().x - AssetManager::getXBackground() < 800 &&\n                Game::getGame()->getHero()->getDirection() == -1) ||\n           (AssetManager::getXBackground() + targetWindow->getSize().x - 800 <\n                Game::getGame()->getHero()->getPosition().x && Game::getGame()->getHero()->getDirection() == 1)) {\n           tempView.move(move.x, 0);\n           targetWindow->setView(tempView);\n       }\n       else\n           move.x = 0;\n\n    float directionEnemy;\n\n    for(const auto& enemy : Game::getGame()->getMapHandler()->getMap()->getEnemies())\n    {\n        sf::Vector2f moveEnemy=sf::Vector2f(0,0);\n        bool found;\n        std::shared_ptr<Bullet> b= nullptr;\n\n       if(enemy->getBehavior()==\"patrol\") {\n           if (patrolClock()) {\n               enemy->setDirection(-1.0f);\n           } else {\n               enemy->setDirection(1.0f);\n           }\n\n           found = enemy->patrol(Game::getGame()->getClock()->getElapsedTime().asSeconds(), enemy->getDirection(),\n                                 sf::Vector2f(Game::getGame()->getHero()->getPosition()), &moveEnemy);\n           moveEnemy = isLegalMovement(enemy,sf::Vector2f(moveEnemy));\n           enemy->sf::Sprite::move(sf::Vector2f(moveEnemy));\n           if(found)\n           {\n               enemy->setBehavior(\"fight\");\n           }\n       }\n       else if(enemy->getBehavior()==\"fight\")\n       {\n           b = enemy->fight(sf::Vector2f(Game::getGame()->getHero()->sf::Sprite::getPosition()),&moveEnemy,Game::getGame()->getClock()->getElapsedTime().asSeconds(),b);\n           moveEnemy = isLegalMovement(enemy,sf::Vector2f(moveEnemy));\n           enemy->sf::Sprite::move(sf::Vector2f(moveEnemy));\n\n           if(b!= nullptr){\n               if(fireClock(enemy->getWeapon()->getFireRate()))\n               {\n                   Game::getGame()->getMapHandler()->getMap()->addBullet(b);\n               }\n           }\n       }\n    }\n\n    animationEnemies();\n\n    checkBullets();\n\n   targetWindow->clear();\n\n   AssetManager::setBackground(targetWindow, move.x);\n\n   generateMap();\n\n   generateGUI(move.x);\n\n   checkCollectables();\n\n    if (Game::getGame()->getHero()->getClockPowerUp().getElapsedTime().asSeconds() > 10 && Game::getGame()->getHero()->isPowerUpState()){\n        Game::getGame()->getHero()->removePowerUp();\n    }\n\n    targetWindow->draw(*Game::getGame()->getHero());\n\n    checkFinished();\n\n}\n\nvoid PlayState::checkFinished(){\n    if (checkCollision(Game::getGame()->getHero(), Game::getGame()->getMapHandler()->getMap()->getPortal()) &&\n    Game::getGame()->getMapHandler()->getMap()->getEnemies().empty()){\n        std::cout<<\"Level completed!\"<<std::endl;\n        Game::getGame()->finishLevel(level);\n    }\n\n}\n\nvoid PlayState::generateMap(){\n    for(const auto& blocks : Game::getGame()->getMapHandler()->getMap()->getMatrix())\n        targetWindow->draw(*blocks);\n    for(const auto& enemy : Game::getGame()->getMapHandler()->getMap()->getEnemies())\n        targetWindow->draw(*enemy);\n    for(const auto& collectable : Game::getGame()->getMapHandler()->getMap()->getCollectables())\n        targetWindow->draw(*collectable);\n    for(const auto& bullet : Game::getGame()->getMapHandler()->getMap()->getBullets())\n        targetWindow->draw(*bullet);\n\n    if(Game::getGame()->getMapHandler()->getMap()->getPortal() != nullptr)\n        targetWindow->draw(*Game::getGame()->getMapHandler()->getMap()->getPortal());\n}\n\n\nvoid PlayState::generateGUI(float& xT){\n    //Health\n    sf::RectangleShape line(sf::Vector2f(104, 15));\n    line.setFillColor(sf::Color::Transparent);\n    line.setOutlineThickness(2);\n    line.setOutlineColor(sf::Color::White);\n    line.setPosition(AssetManager::getXBackground() + 100,50);\n\n    sf::RectangleShape health(sf::Vector2f(Game::getGame()->getHero()->getHealthPoint(), 11));\n    health.setFillColor(sf::Color::Red);\n    health.setPosition(AssetManager::getXBackground() + 102,52);\n\n    //Munitions\n    sf::Sprite currentAmmoSprite;\n    currentAmmoSprite.setTexture(AssetManager::textures.at(\"MUNITIONS\"));\n    currentAmmoSprite.setPosition(line.getPosition().x + line.getSize().x + 50, line.getPosition().y - 5);\n    currentAmmoSprite.setScale(0.05,0.05);\n\n    sf::Text nMunitions;\n    nMunitions.setFont(*AssetManager::font);\n    nMunitions.setString(std::to_string(Game::getGame()->getHero()->getAmmo()));\n    nMunitions.setCharacterSize(20);\n    nMunitions.setPosition(currentAmmoSprite.getPosition().x + 35, currentAmmoSprite.getPosition().y);\n\n    //Coins\n    sf::Sprite currentCoinsSprite;\n    currentCoinsSprite.setTexture(AssetManager::textures.at(\"COINS\"));\n    currentCoinsSprite.setPosition(currentAmmoSprite.getPosition().x + 80, currentAmmoSprite.getPosition().y - 3);\n    currentCoinsSprite.setScale(0.06,0.06);\n\n    sf::Text nCoins;\n    nCoins.setFont(*AssetManager::font);\n    nCoins.setString(std::to_string(Game::getGame()->getHero()->getCoins()));\n    nCoins.setCharacterSize(20);\n    nCoins.setPosition(currentCoinsSprite.getPosition().x + 35, currentCoinsSprite.getPosition().y + 3);\n\n    targetWindow->draw(line);\n    targetWindow->draw(health);\n    targetWindow->draw(currentAmmoSprite);\n    targetWindow->draw(nMunitions);\n    targetWindow->draw(currentCoinsSprite);\n    targetWindow->draw(nCoins);\n\n    sf::Text message;\n    message.setFont(*AssetManager::font);\n    message.setString(Game::getGame()->getHero()->getTypePowerUp());\n    message.setCharacterSize(25);\n    message.setPosition(AssetManager::getXBackground() + targetWindow->getView().getSize().x/2 - message.getLocalBounds().width/2, nCoins.getPosition().y+3);\n    if(Game::getGame()->getHero()->isPowerUpState()){\n        targetWindow->draw(message);\n    }\n\n}\n\nvoid PlayState::animationHero(int direction, sf::Vector2f speed) {\n    float speedClock = 0.1;\n\n    if (Game::getGame()->getHero()->getClockAnimation()->getElapsedTime().asSeconds()>speedClock && direction == 0) {\n        if(Game::getGame()->getHero()->getStrTexture().back() == 'd'){\n            Game::getGame()->getHero()->setTexture(AssetManager::textures.at(\"Idle_1_Reversed\"));\n            Game::getGame()->getHero()->setStrTexture(\"Idle_1_Reversed\");\n        }else{\n            Game::getGame()->getHero()->setTexture(AssetManager::textures.at(\"Idle_1\"));\n            Game::getGame()->getHero()->setStrTexture(\"Idle_1\");\n        }\n\n    }else if(Game::getGame()->getHero()->getClockAnimation()->getElapsedTime().asSeconds()>speedClock && direction > 0){\n        Game::getGame()->getHero()->getClockAnimation()->restart();\n        if(Game::getGame()->getHero()->getStrTexture() == \"Run_6\" || Game::getGame()->getHero()->getStrTexture() == \"Idle_1\"\n            || Game::getGame()->getHero()->getStrTexture().back() == 'd'){\n            Game::getGame()->getHero()->setTexture(AssetManager::textures.at(\"Run_1\"));\n            Game::getGame()->getHero()->setStrTexture(\"Run_1\");\n        } else if(Game::getGame()->getHero()->getStrTexture() == \"Run_1\"){\n            Game::getGame()->getHero()->setTexture(AssetManager::textures.at(\"Run_2\"));\n            Game::getGame()->getHero()->setStrTexture(\"Run_2\");\n        }else if(Game::getGame()->getHero()->getStrTexture() == \"Run_2\"){\n            Game::getGame()->getHero()->setTexture(AssetManager::textures.at(\"Run_3\"));\n            Game::getGame()->getHero()->setStrTexture(\"Run_3\");\n        } else if(Game::getGame()->getHero()->getStrTexture() == \"Run_3\"){\n            Game::getGame()->getHero()->setTexture(AssetManager::textures.at(\"Run_4\"));\n            Game::getGame()->getHero()->setStrTexture(\"Run_4\");\n        }else if(Game::getGame()->getHero()->getStrTexture() == \"Run_4\"){\n            Game::getGame()->getHero()->setTexture(AssetManager::textures.at(\"Run_5\"));\n            Game::getGame()->getHero()->setStrTexture(\"Run_5\");\n        }else if(Game::getGame()->getHero()->getStrTexture() == \"Run_5\"){\n            Game::getGame()->getHero()->setTexture(AssetManager::textures.at(\"Run_6\"));\n            Game::getGame()->getHero()->setStrTexture(\"Run_6\");\n        }\n\n    }else if(Game::getGame()->getHero()->getClockAnimation()->getElapsedTime().asSeconds()>speedClock && direction < 0){\n        Game::getGame()->getHero()->getClockAnimation()->restart();\n        if(Game::getGame()->getHero()->getStrTexture() == \"Run_6_Reversed\" || Game::getGame()->getHero()->getStrTexture() == \"Idle_1\"\n            || Game::getGame()->getHero()->getStrTexture() == \"Idle_1_Reversed\" || Game::getGame()->getHero()->getStrTexture().back() != 'd'){\n            Game::getGame()->getHero()->setTexture(AssetManager::textures.at(\"Run_1_Reversed\"));\n            Game::getGame()->getHero()->setStrTexture(\"Run_1_Reversed\");\n        } else if(Game::getGame()->getHero()->getStrTexture() == \"Run_1_Reversed\"){\n            Game::getGame()->getHero()->setTexture(AssetManager::textures.at(\"Run_2_Reversed\"));\n            Game::getGame()->getHero()->setStrTexture(\"Run_2_Reversed\");\n        }else if(Game::getGame()->getHero()->getStrTexture() == \"Run_2_Reversed\"){\n            Game::getGame()->getHero()->setTexture(AssetManager::textures.at(\"Run_3_Reversed\"));\n            Game::getGame()->getHero()->setStrTexture(\"Run_3_Reversed\");\n        } else if(Game::getGame()->getHero()->getStrTexture() == \"Run_3_Reversed\"){\n            Game::getGame()->getHero()->setTexture(AssetManager::textures.at(\"Run_4_Reversed\"));\n            Game::getGame()->getHero()->setStrTexture(\"Run_4_Reversed\");\n        }else if(Game::getGame()->getHero()->getStrTexture() == \"Run_4_Reversed\"){\n            Game::getGame()->getHero()->setTexture(AssetManager::textures.at(\"Run_5_Reversed\"));\n            Game::getGame()->getHero()->setStrTexture(\"Run_5_Reversed\");\n        }else if(Game::getGame()->getHero()->getStrTexture() == \"Run_5_Reversed\"){\n            Game::getGame()->getHero()->setTexture(AssetManager::textures.at(\"Run_6_Reversed\"));\n            Game::getGame()->getHero()->setStrTexture(\"Run_6_Reversed\");\n        }\n    }\n\n}\n\nvoid PlayState::animationEnemies(){\n    std::string color;\n\n    for(const auto& enemy : Game::getGame()->getMapHandler()->getMap()->getEnemies()){\n\n        if(enemy->getBehaviorType() == \"Wizard\"){\n\n            color = \"Blue\";\n\n        }else if (enemy->getBehavior() == \"Sentinel\"){\n\n            color = \"Gray\";\n\n        }else{\n\n            color = \"Red\";\n\n        }\n\n        animateEnemy(enemy, color);\n    }\n}\n\nvoid PlayState::animateEnemy(std::shared_ptr<Enemy> enemy,std::string color){\n    float speedClock = 0.12;\n\n    if (enemy->getClockAnimation()->getElapsedTime().asSeconds()>speedClock && enemy->getDirection() == 0) {\n        if(enemy->getStrTexture().back() == 'd'){\n            enemy->setTexture(AssetManager::textures.at(color+\"_Idle_1_Reversed\"));\n            enemy->setStrTexture(color+\"_Idle_1_Reversed\");\n        }else{\n            enemy->setTexture(AssetManager::textures.at(color+\"_Idle_1\"));\n            enemy->setStrTexture(color+\"_Idle_1\");\n        }\n    }\n    if(enemy->getClockAnimation()->getElapsedTime().asSeconds()>speedClock && enemy->getDirection() > 0){\n        enemy->getClockAnimation()->restart();\n        if(enemy->getStrTexture() == color+\"_Run_6\" || enemy->getStrTexture() == color+\"_Idle_1\"\n           || enemy->getStrTexture().back() == 'd'){\n            enemy->setTexture(AssetManager::textures.at(color+\"_Run_1\"));\n            enemy->setStrTexture(color+\"_Run_1\");\n        } else if(enemy->getStrTexture() == color+\"_Run_1\"){\n            enemy->setTexture(AssetManager::textures.at(color+\"_Run_2\"));\n            enemy->setStrTexture(color+\"_Run_2\");\n        }else if(enemy->getStrTexture() == color+\"_Run_2\"){\n            enemy->setTexture(AssetManager::textures.at(color+\"_Run_3\"));\n            enemy->setStrTexture(color+\"_Run_3\");\n        } else if(enemy->getStrTexture() == color+\"_Run_3\"){\n            enemy->setTexture(AssetManager::textures.at(color+\"_Run_4\"));\n            enemy->setStrTexture(color+\"_Run_4\");\n        }else if(enemy->getStrTexture() == color+\"_Run_4\"){\n            enemy->setTexture(AssetManager::textures.at(color+\"_Run_5\"));\n            enemy->setStrTexture(color+\"_Run_5\");\n        }else if(enemy->getStrTexture() == color+\"_Run_5\"){\n            enemy->setTexture(AssetManager::textures.at(color+\"_Run_6\"));\n            enemy->setStrTexture(color+\"_Run_6\");\n        }else{\n            enemy->setTexture(AssetManager::textures.at(color+\"_Run_1\"));\n            enemy->setStrTexture(color+\"_Run_1\");\n        }\n\n    }else if(enemy->getClockAnimation()->getElapsedTime().asSeconds()>speedClock && enemy->getDirection() < 0){\n        enemy->getClockAnimation()->restart();\n        if(enemy->getStrTexture() == color+\"_Run_6_Reversed\" || enemy->getStrTexture() == color+\"_Idle_1\"\n           || enemy->getStrTexture() == color+\"_Idle_1_Reversed\" || enemy->getStrTexture().back() != 'd'){\n            enemy->setTexture(AssetManager::textures.at(color+\"_Run_1_Reversed\"));\n            enemy->setStrTexture(color+\"_Run_1_Reversed\");\n        } else if(enemy->getStrTexture() == color+\"_Run_1_Reversed\"){\n            enemy->setTexture(AssetManager::textures.at(color+\"_Run_2_Reversed\"));\n            enemy->setStrTexture(color+\"_Run_2_Reversed\");\n        }else if(enemy->getStrTexture() == color+\"_Run_2_Reversed\"){\n            enemy->setTexture(AssetManager::textures.at(color+\"_Run_3_Reversed\"));\n            enemy->setStrTexture(color+\"_Run_3_Reversed\");\n        } else if(enemy->getStrTexture() == color+\"_Run_3_Reversed\"){\n            enemy->setTexture(AssetManager::textures.at(color+\"_Run_4_Reversed\"));\n            enemy->setStrTexture(color+\"_Run_4_Reversed\");\n        }else if(enemy->getStrTexture() == color+\"_Run_4_Reversed\"){\n            enemy->setTexture(AssetManager::textures.at(color+\"_Run_5_Reversed\"));\n            enemy->setStrTexture(color+\"_Run_5_Reversed\");\n        }else if(enemy->getStrTexture() == color+\"_Run_5_Reversed\"){\n            enemy->setTexture(AssetManager::textures.at(color+\"_Run_6_Reversed\"));\n            enemy->setStrTexture(color+\"_Run_6_Reversed\");\n        }else{\n            enemy->setTexture(AssetManager::textures.at(color+\"_Run_1_Reversed\"));\n            enemy->setStrTexture(color+\"_Run_1_Reversed\");\n        }\n    }\n\n}\n\n\nsf::Vector2f PlayState::isLegalMovement(const std::shared_ptr<GameCharacter>& entity, sf::Vector2f move){\n    sf::Vector2f moving = move;\n    sf::Vector2f entityPos = entity->getPosition();\n    sf::Vector2u entitySize = entity->getTexture()->getSize();\n    sf::Vector2f entityScale = entity->getScale();\n\n    entityPos.x += entitySize.x*entityScale.x/2.0f;\n    entityPos.y += entitySize.y*entityScale.y/2.0f;\n\n    float deltaX;\n    float deltaY;\n    float intersectionX;\n    float intersectionY;\n\n    int rightCollision = 0;\n    int leftCollision = 0;\n    int bottomtCollision = 0;\n    int topCollision = 0;\n\n    bool rightCollisionBool = false;\n    bool leftCollisionBool = false;\n    bool bottomtCollisionBool = false;\n    bool topCollisionBool = false;\n\n\n    for(const auto& block : Game::getGame()->getMapHandler()->getMap()->getMatrix()){\n        deltaX  = entityPos.x + moving.x - (block->getPosition().x + block->getTexture()->getSize().x * block->getScale().x /2.0f);\n        intersectionX = fabs(deltaX) - ((entitySize.x*entityScale.x/2) + (block->getTexture()->getSize().x*block->getScale().x/2.0f));\n        deltaY  = entityPos.y + moving.y - (block->getPosition().y + block->getTexture()->getSize().y * block->getScale().y /2.0f);\n        intersectionY = fabs(deltaY) - ((entitySize.y*entityScale.y/2) + (block->getTexture()->getSize().y*block->getScale().y/2.0f));\n\n\n        if(intersectionY < 0.0f && intersectionX < 0.0f){ //se entra qui collide con un blocco\n\n            rightCollisionBool = false;\n            leftCollisionBool = false;\n            bottomtCollisionBool = false;\n            topCollisionBool = false;\n\n            //std::cout<<\"\\n\\nMove X: \"<< move.x << \" Y: \"<<move.y<<std::endl;\n            //std::cout<<\"Collision with: X: \"<< block->getPosition().x/64 << \" Y: \"<<block->getPosition().y/64 << std::endl;\n\n            if(intersectionX > intersectionY){\n                if(deltaX > 0.0f){\n                    leftCollision++;\n                    leftCollisionBool = true;\n                    //std::cout<<\"Left Collision!\";\n                }else{\n                    rightCollision++;\n                    rightCollisionBool = true;\n                    //std::cout<<\"Right Collision!\";\n                }\n            }\n            else{\n                 if(deltaY < 0.0f){\n                     bottomtCollision++;\n                     bottomtCollisionBool = true;\n                     //std::cout<<\"Bottom Collision!\";\n                 }else{\n                     topCollision++;\n                     topCollisionBool = true;\n                     //std::cout<<\"Top Collision!\";\n                 }\n            }\n\n            if(leftCollision == 1 && leftCollisionBool){\n                moving.x -= intersectionX;\n                entity->setSpeed(sf::Vector2f(0,entity->getSpeed().y));\n            }\n\n            if(rightCollision == 1 && rightCollisionBool){\n                moving.x += intersectionX;\n                entity->setSpeed(sf::Vector2f(0,entity->getSpeed().y));\n            }\n\n            if(topCollision == 1 && topCollisionBool){\n                moving.y -= intersectionY;\n                entity->setSpeed(sf::Vector2f(entity->getSpeed().x,0));\n            }\n\n            if(bottomtCollision == 1 && bottomtCollisionBool){\n                moving.y += intersectionY;\n                entity->setSpeed(sf::Vector2f(entity->getSpeed().x,0));\n            }\n\n        }\n\n    }\n\n    /*\n    if(leftCollision > 0 || rightCollision > 0 || topCollision > 0 || bottomtCollision > 0){\n        std::cout<<\"\\nnCollisions: \" << leftCollision + rightCollision + topCollision + bottomtCollision<<std::endl;\n        std::cout<<\"Moving X: \"<<moving.x<<\" Y: \"<<moving.y<<std::endl;\n\n    }\n    */\n    return moving;\n}\n\nbool PlayState::checkCollision(const std::shared_ptr<sf::Sprite>& entity1, const std::shared_ptr<sf::Sprite>& entity2){\n    bool collision = false;\n\n    sf::Vector2f entityPos = entity1->getPosition();\n    sf::Vector2u entitySize = entity1->getTexture()->getSize();\n    sf::Vector2f entityScale = entity1->getScale();\n\n    entityPos.x += entitySize.x*entityScale.x/2.0f;\n    entityPos.y += entitySize.y*entityScale.y/2.0f;\n\n    float deltaX = entityPos.x - (entity2->getPosition().x + entity2->getTexture()->getSize().x * entity2->getScale().x /2.0f);\n    float deltaY = entityPos.y - (entity2->getPosition().y + entity2->getTexture()->getSize().y * entity2->getScale().y /2.0f);\n    float intersectionX = std::fabs(deltaX) - ((entitySize.x*entityScale.x/2) + (entity2->getTexture()->getSize().x*entity2->getScale().x/2.0f));\n    float intersectionY = std::fabs(deltaY) - ((entitySize.y*entityScale.y/2) + (entity2->getTexture()->getSize().y*entity2->getScale().y/2.0f));\n\n    if(intersectionY < 0.0f && intersectionX < 0.0f){\n        collision = true;\n    }\n\n    return collision;\n}\n\n\nvoid PlayState::checkCollectables(){\n    int i=0;\n    for(const auto& collectable : Game::getGame()->getMapHandler()->getMap()->getCollectables()){\n        if(checkCollision(collectable, Game::getGame()->getHero()))\n            collectable->notifyObservers(i);\n        i++;\n    }\n}\n\nvoid PlayState::checkBullets(){\n    int i=0, hp = 0;\n    bool deleted = false, killedHero = false;\n    for(const auto& bullet : Game::getGame()->getMapHandler()->getMap()->getBullets()){\n        bullet->move(Game::getGame()->getClock()->getElapsedTime().asSeconds());\n        deleted = false;\n        if (!spriteInView(*bullet)){\n            deleted = true;\n            Game::getGame()->getMapHandler()->getMap()->removeBullet(i);\n            //std::cout<<\"Removed or view\"<<std::endl;\n        }else if(checkCollision(bullet, Game::getGame()->getHero()) && !bullet->isFriendly()) {\n            deleted = true;\n            hp = Game::getGame()->getHero()->receiveDamage(bullet->getDamage());\n            Game::getGame()->getMapHandler()->getMap()->removeBullet(i);\n            if(hp < 1){\n                //Game::getGame()->killHero();\n                killedHero = true;\n            }\n            //std::cout<<\"Removed for hero\"<<std::endl;\n        }else{\n            if(!deleted){\n                for(const auto& enemy : Game::getGame()->getMapHandler()->getMap()->getEnemies()){\n                    if(checkCollision(bullet, enemy) && bullet->isFriendly() && !deleted){\n                        deleted = true;\n                        hp = enemy->receiveDamage(bullet->getDamage());\n                        //std::cout<<\"Enemy hp: \"<<hp<<std::endl;\n                        if(hp < 1)\n                            Game::getGame()->getMapHandler()->getMap()->removeEnemy(i);\n                        Game::getGame()->getMapHandler()->getMap()->removeBullet(i);\n                        //std::cout<<\"Removed for enemy\"<<std::endl;\n                    }\n                }\n            }\n            if(!deleted){\n                for(const auto& block : Game::getGame()->getMapHandler()->getMap()->getMatrix()){\n                    if(checkCollision(bullet, block) && !deleted){\n                        deleted = true;\n                        Game::getGame()->getMapHandler()->getMap()->removeBullet(i);\n                        //std::cout<<\"Removed for block\"<<std::endl;\n                    }\n                }\n            }\n\n        }\n        //std::cout<<\"i: \"<<i<<std::endl;\n        i++;\n    }\n\n    if(killedHero)\n        Game::getGame()->killHero();\n\n\n}\n\nbool PlayState::spriteInView(sf::Sprite sprite)\n{\n    sf::Vector2f viewSize(targetWindow->getView().getSize());\n    sf::Vector2f viewCenter(targetWindow->getView().getCenter());\n\n    sf::Vector2i spritePosition = sf::Vector2i (sprite.getPosition());\n\n    return !(std::fabs(spritePosition.x - viewCenter.x) > viewSize.x / 2 ||\n             std::fabs(spritePosition.y - viewCenter.y) > viewSize.y / 2);\n}\n\nint PlayState::getAction() const {\n    return action;\n}\n\nvoid PlayState::setAction(int action) {\n    PlayState::action = action;\n}\n\nbool PlayState::patrolClock() {\n    if(directionClock->getElapsedTime().asSeconds()>3.0f)\n    {\n        if(directionClock->getElapsedTime().asSeconds()>6.0f)\n            directionClock->restart();\n        return true;\n    }\n    return false;\n}\n\nbool PlayState:: fireClock(float fireRate){\n    if(combactClock->getElapsedTime().asSeconds()>1.0f/fireRate)\n    {\n        combactClock->restart();\n        return true;\n    }\n\n    return false;\n}\n\n\n\n/*\n    // Qui sto provando a fare meno controlli (quindi controllo solo i due blocchi accanto a Hero per renderlo piè efficiente)\n    //da errore perchè non si controlla il massimo indice\n    int x = int(entityPos.x/64);\n    int y = int(entityPos.y/64);\n\n\n    if(y < 8)\n        y = 8;\n    if(x < 8)\n        x = 8;\n\n    std::shared_ptr<sf::Sprite> block;\n\n    for(int i = x - 8; i < x + 9; i++){\n        for(int j = y - 8; j < y + 9; j++){\n\n            //std::cout<<i * Game::getGame()->getMapHandler()->getMap()->getN() + j<<std::endl;\n\n            std::cout<<\"\\n1\";\n            block = Game::getGame()->getMapHandler()->getMap()->getFromMatrix(i * Game::getGame()->getMapHandler()->getMap()->getN() + j);\n            std::cout<<\"2\";\n\n            deltaX  = entityPos.x - (block->getPosition().x + block->getTexture()->getSize().x * block->getScale().x /2.0f);\n            intersectionX = fabs(deltaX) - ((entitySize.x*entityScale.x/2) + (block->getTexture()->getSize().x*block->getScale().x/2.0f));\n            deltaY  = entityPos.y - (block->getPosition().y + block->getTexture()->getSize().y * block->getScale().y /2.0f);\n            intersectionY = fabs(deltaY) - ((entitySize.y*entityScale.y/2) + (block->getTexture()->getSize().y*block->getScale().y/2.0f));\n\n\n            if(intersectionY < 0.0f && intersectionX < 0.0f){\n\n                rightCollisionBool = false;\n                leftCollisionBool = false;\n                bottomtCollisionBool = false;\n                topCollisionBool = false;\n\n                if(intersectionX > intersectionY){\n                    if(deltaX > 0.0f){\n                        leftCollision++;\n                        leftCollisionBool = true;\n                    }else{\n                        rightCollision++;\n                        rightCollisionBool = true;\n                    }\n                }\n                else{\n                     if(deltaY < 0.0f){\n                         bottomtCollision++;\n                         bottomtCollisionBool = true;\n                     }else{\n                         topCollision++;\n                         topCollisionBool = true;\n                     }\n                }\n\n                if(leftCollision == 1 && leftCollisionBool){\n                    moving.x -= intersectionX;\n                    Game::getGame()->getHero()->setSpeed(sf::Vector2f(0,Game::getGame()->getHero()->getSpeed().y));\n                }\n\n                if(rightCollision == 1 && rightCollisionBool){\n                    moving.x += intersectionX;\n                    Game::getGame()->getHero()->setSpeed(sf::Vector2f(0,Game::getGame()->getHero()->getSpeed().y));\n                }\n\n                if(topCollision == 1 && topCollisionBool){\n                    moving.y -= intersectionY;\n                    Game::getGame()->getHero()->setSpeed(sf::Vector2f(Game::getGame()->getHero()->getSpeed().x,0));\n                }\n\n                if(bottomtCollision == 1 && bottomtCollisionBool){\n                    moving.y += intersectionY;\n                    Game::getGame()->getHero()->setSpeed(sf::Vector2f(Game::getGame()->getHero()->getSpeed().x,0));\n                }\n\n            }\n        }\n    }\n\n*/
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- States/PlayState.cpp	(revision f70a6a81c44e42ec5b095543fc0c44cd7e0c87a8)
-+++ States/PlayState.cpp	(date 1594285231873)
-@@ -153,6 +153,7 @@
-        }
-     }
- 
-+
-     animationEnemies();
- 
-     checkBullets();
-Index: test/TestEnemyBehavior.cpp
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>//\n// Created by Lorenzo Massa on 03/07/20.\n//\n\n#include <gtest/gtest.h>\n\n/*\nclass TestEnemyBehavior : public ::testing::Test {\nprotected:\n    virtual void SetUp() {\n        AssetManager::load();\n        AssetManager::setFrames();\n        TargetWindow targetWindow = std::make_shared<sf::RenderWindow>();\n        PlayState state = PlayState(targetWindow);\n    }\n\n    virtual void TearDown() {\n\n    }\n};\n\nTEST_F(TestEnemyBehavior, TEST_BRAWLER_ACTION) {\n//(0, 0)\nauto brawler = GameFactory::makeBrawlewr(0);\nauto action = brawler->action(sf::Vector2f(1000, 1000));\nASSERT_GT(brawler->getSpeed().x, 0);\nASSERT_GT(brawler->getSpeed().y, 0);\nASSERT_EQ(action, nullptr);\n\n}\n\nTEST_F(TestEnemyBehavior, TEST_WATCHER_ACTION) {\nauto watcher = GameFactory::makeWatcher(0);\nauto color = watcher->getColor().a;\nauto bullet = watcher->action(sf::Vector2f(3000,0));\nfor(int i=0; i<300; i++){\nwatcher->action(sf::Vector2f(3000,0));\nASSERT_LE(watcher->getColor().a, color);\ncolor = watcher->getColor().a;\n}\nEXPECT_EQ(color,30);\nfor (int i=0; i<300; i++){\nwatcher->action(sf::Vector2f(0,0));\nASSERT_GE(watcher->getColor().a, color);\ncolor = watcher->getColor().a;\n}\nEXPECT_EQ(color, 255);\nASSERT_EQ(bullet, nullptr);\n}\n\nTEST_F(TestEnemyBehavior, TEST_ARCHER_ACTION){\nTimer::getTimer();\nauto archer = GameFactory::makeArcher(0);\nsf::Clock clock;\nclock.restart();\nwhile (clock.getElapsedTime() < sf::seconds(4)){}\nauto bullet = archer->action(sf::Vector2f(2,0));\nASSERT_NE(bullet, nullptr);\nASSERT_GT(bullet->getComponent().x,0);\nclock.restart();\nwhile (clock.getElapsedTime() < sf::seconds(4)){}\nbullet = archer->action(sf::Vector2f(-1,0));\nASSERT_NE(bullet, nullptr);\nASSERT_LT(bullet->getComponent().x,0);\nbullet = archer->action(sf::Vector2f(-1,0));\nASSERT_EQ(bullet, nullptr);\n\n}\n\n */
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- test/TestEnemyBehavior.cpp	(revision f70a6a81c44e42ec5b095543fc0c44cd7e0c87a8)
-+++ test/TestEnemyBehavior.cpp	(date 1594284171540)
-@@ -3,15 +3,23 @@
- //
- 
- #include <gtest/gtest.h>
-+#include "../Engine/Game.h"
-+#include "../States/PlayState.h"
-+#include "../States/LevelSelectState.h"
- 
--/*
-+
- class TestEnemyBehavior : public ::testing::Test {
- protected:
-+    std::shared_ptr<Game> game;
-+    std::shared_ptr<PlayState> playState;
-+
-     virtual void SetUp() {
--        AssetManager::load();
--        AssetManager::setFrames();
--        TargetWindow targetWindow = std::make_shared<sf::RenderWindow>();
--        PlayState state = PlayState(targetWindow);
-+        game = Game::getGame();
-+        game->init();
-+        game->getStateHandler()->addState(std::make_shared<LevelSelectState>(game->getWindow()));
-+        game->getMapHandler()->loadLevel(1);
-+        playState = std::make_shared<PlayState>(game->getWindow(),1);
-+        game->getStateHandler()->addState(playState);
-     }
- 
-     virtual void TearDown() {
-@@ -19,52 +27,10 @@
-     }
- };
- 
--TEST_F(TestEnemyBehavior, TEST_BRAWLER_ACTION) {
--//(0, 0)
--auto brawler = GameFactory::makeBrawlewr(0);
--auto action = brawler->action(sf::Vector2f(1000, 1000));
--ASSERT_GT(brawler->getSpeed().x, 0);
--ASSERT_GT(brawler->getSpeed().y, 0);
--ASSERT_EQ(action, nullptr);
--
--}
-+TEST_F(TestEnemyBehavior, TestChengeBehavior) {
- 
--TEST_F(TestEnemyBehavior, TEST_WATCHER_ACTION) {
--auto watcher = GameFactory::makeWatcher(0);
--auto color = watcher->getColor().a;
--auto bullet = watcher->action(sf::Vector2f(3000,0));
--for(int i=0; i<300; i++){
--watcher->action(sf::Vector2f(3000,0));
--ASSERT_LE(watcher->getColor().a, color);
--color = watcher->getColor().a;
--}
--EXPECT_EQ(color,30);
--for (int i=0; i<300; i++){
--watcher->action(sf::Vector2f(0,0));
--ASSERT_GE(watcher->getColor().a, color);
--color = watcher->getColor().a;
--}
--EXPECT_EQ(color, 255);
--ASSERT_EQ(bullet, nullptr);
--}
- 
--TEST_F(TestEnemyBehavior, TEST_ARCHER_ACTION){
--Timer::getTimer();
--auto archer = GameFactory::makeArcher(0);
--sf::Clock clock;
--clock.restart();
--while (clock.getElapsedTime() < sf::seconds(4)){}
--auto bullet = archer->action(sf::Vector2f(2,0));
--ASSERT_NE(bullet, nullptr);
--ASSERT_GT(bullet->getComponent().x,0);
--clock.restart();
--while (clock.getElapsedTime() < sf::seconds(4)){}
--bullet = archer->action(sf::Vector2f(-1,0));
--ASSERT_NE(bullet, nullptr);
--ASSERT_LT(bullet->getComponent().x,0);
--bullet = archer->action(sf::Vector2f(-1,0));
--ASSERT_EQ(bullet, nullptr);
- 
- }
- 
-- */
-\ No newline at end of file
-+
-Index: test/TestHero.cpp
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>//\n// Created by Lorenzo Massa on 29/06/2020.\n//\n\n#include <AssetsManager.h>\n#include \"gtest/gtest.h\"\n#include \"../GameCharacter/Hero.h\"\n\nclass TestHero : public ::testing::Test {\n\nprotected:\n\n\n    Hero* hero;\n\n    virtual void SetUp() {\n        AssetManager::load();\n        auto s = sf::Vector2f(0,0);\n        auto pos = sf::Vector2f(0,0);\n        hero = new Hero(1,100,50,50,s,pos,0,1,0);\n    }\n\n    virtual void TearDown() {\n        delete hero;\n    }\n\n\n};\n\nTEST_F(TestHero,jumpTest){\n    auto speed = hero->getSpeed();\n    hero->jump();\n\n    ASSERT_EQ(speed.y - 25.0f*64.0f,hero->getSpeed().y);\n    ASSERT_EQ(speed.x, hero->getSpeed().x);\n}\n\nTEST_F(TestHero,gravityTest){\n    float deltaT = 1.0f/60;\n    auto direction = sf::Vector2f(0,0);\n    auto moving = hero->move(direction, deltaT);\n\n    hero->sf::Sprite::move(moving);\n\n    ASSERT_EQ(0, hero->getPosition().x);\n    ASSERT_EQ((hero->getSpeed().y*deltaT+0.5f*98.0f*64.0f*deltaT*deltaT)*direction.y, hero->getPosition().y);\n\n}\n\nTEST_F(TestHero,shotTest){\n    auto bullet = hero->shot(sf::Vector2f (hero->getPos().x+50, hero->getPos().y+hero->getTexture()->getSize().y*hero->getScale().y));\n\n    ASSERT_NE( bullet, nullptr);\n\n    ASSERT_EQ(bullet->getPosition().x,hero->getPosition().x+32);\n    ASSERT_EQ(bullet->getPosition().y,hero->getPosition().y+64);\n}\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- test/TestHero.cpp	(revision f70a6a81c44e42ec5b095543fc0c44cd7e0c87a8)
-+++ test/TestHero.cpp	(date 1594283863805)
-@@ -55,3 +55,5 @@
-     ASSERT_EQ(bullet->getPosition().x,hero->getPosition().x+32);
-     ASSERT_EQ(bullet->getPosition().y,hero->getPosition().y+64);
- }
-+
-+
